# -*- coding: utf-8 -*-
"""Makhdoom_Faiqueali_assignement_part1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FVGJC5LBU7z_1k9L34mYxVH1HzsQxYO3
"""

import pandas as pd
import numpy as np
import re
from datetime import datetime

# Load the data
doc = []
with open('/content/dates.txt') as file:
    for line in file:
        doc.append(line)

df = pd.Series(doc)
print(f"Loaded {len(df)} medical notes")
print("\nFirst 5 notes:")
print(df.head())

import re

# Example df for demonstration
df = [
    "The event is on 12/25/2024 and registration closes 11/30/23.",
    "Another date is 01/01/2025.",
    "Invalid date 13/40/2020 should not match."
]

def question_one():
    """
    Extract all dates in MM/DD/YY or MM/DD/YYYY format.

    Returns:
        list: List of matched date strings
    """
    # Regex pattern for MM/DD/YY or MM/DD/YYYY
    # MM: 01-12, DD: 01-31, YY: 2 digits, YYYY: 4 digits
    pattern = r"\b(0[1-9]|1[0-2])/([0-2][0-9]|3[01])/(\d{2}|\d{4})\b"

    results = []
    for note in df:
        matches = re.findall(pattern, note)
        # Each match is a tuple (MM, DD, YY/YYYY), join them back
        matches = [f"{m[0]}/{m[1]}/{m[2]}" for m in matches]
        results.extend(matches)

    return results

# Test your function
q1_result = question_one()
print(f"Found {len(q1_result)} dates")
print(f"First 10: {q1_result[:10]}")

import re

# Example df with month-name dates
df = [
    "The event was held on Mar 20, 2009.",
    "Another important date is February 5, 2020.",
    "Incorrect date March 32, 2010 should not match.",
    "Short form: Jul 4, 1776."
]

def question_two():
    """
    Extract all dates with month names (e.g., Mar 20, 2009).

    Returns:
        list: List of matched date strings
    """
    # Regex pattern for month-name dates (abbreviated or full)
    # Month: Jan|Feb|...|December
    # Day: 1-31 (with optional leading 0)
    # Year: 4 digits
    pattern = r'\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|' \
              r'January|February|March|April|May|June|July|August|' \
              r'September|October|November|December) ' \
              r'(0?[1-9]|[12][0-9]|3[01]), (\d{4})\b'

    results = []
    for note in df:
        matches = re.findall(pattern, note)
        # Each match is a tuple (day, year), prepend month using lookahead
        for match in matches:
            # Extract the month name from the text
            month_search = re.search(r'\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|'
                                     r'January|February|March|April|May|June|July|August|'
                                     r'September|October|November|December) ' +
                                     match[0] + r', ' + match[1], note)
            if month_search:
                results.append(month_search.group())

    return results

# Test your function
q2_result = question_two()
print(f"Found {len(q2_result)} dates")
print(f"First 10: {q2_result[:10]}")

import re

# Example df with DD Month YYYY dates
df = [
    "The event happened on 20 March 2009.",
    "Another date is 5 February 2020.",
    "Incorrect date 32 January 2010 should not match.",
    "Historical date: 04 July 1776."
]

def question_three():
    """
    Extract all dates in DD Month YYYY format.

    Returns:
        list: List of matched date strings
    """
    # Regex pattern: day (1-31), month name (full), year (4 digits)
    pattern = r'\b(0?[1-9]|[12][0-9]|3[01]) ' \
              r'(January|February|March|April|May|June|July|August|' \
              r'September|October|November|December) ' \
              r'(\d{4})\b'

    results = []
    for note in df:
        matches = re.findall(pattern, note)
        # Each match is a tuple (DD, Month, YYYY)
        matches = [f"{m[0]} {m[1]} {m[2]}" for m in matches]
        results.extend(matches)

    return results

# Test your function
q3_result = question_three()
print(f"Found {len(q3_result)} dates")
print(f"First 10: {q3_result[:10]}")

import re

def question_four(text):
    """
    Extract all email addresses from text.

    Args:
        text (str): Input text

    Returns:
        list: List of email addresses
    """
    # Regex pattern for standard emails
    pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'

    return re.findall(pattern, text)

# Test your function
test_text = """
Contact us at support@company.com or sales@company.org.
You can also reach john.doe@email.co.uk or jane_doe123@university.edu.
Invalid emails: @invalid.com, user@, not-an-email
"""

q4_result = question_four(test_text)
print(f"Found emails: {q4_result}")

import re
import string

def question_five(text):
    """
    Clean text by removing digits, punctuation, and normalizing whitespace.

    Args:
        text (str): Input text

    Returns:
        str: Cleaned text
    """
    # Step 1: Convert to lowercase
    text = text.lower()

    # Step 2: Remove digits
    text = re.sub(r'\d+', '', text)

    # Step 3: Remove punctuation
    text = text.translate(str.maketrans('', '', string.punctuation))

    # Step 4: Normalize whitespace (replace multiple spaces/newlines with single space)
    text = " ".join(text.split())

    return text

# Test your function
test_text = "Hello, World! 123 This is a TEST... with 456 numbers!!!"
q5_result = question_five(test_text)
print(f"Original: '{test_text}'")
print(f"Cleaned:  '{q5_result}'")

import re

def question_six(text):
    """
    Extract phone numbers and return them in XXX-XXX-XXXX format.

    Args:
        text (str): Input text

    Returns:
        list: List of phone numbers in XXX-XXX-XXXX format
    """
    # Regex pattern to match different phone formats:
    # 123-456-7890, (123) 456-7890, 123.456.7890, 123 456 7890
    pattern = r'\(?(\d{3})\)?[-.\s]?(\d{3})[-.\s](\d{4})'

    matches = re.findall(pattern, text)

    # Standardize format to XXX-XXX-XXXX
    standardized = [f"{m[0]}-{m[1]}-{m[2]}" for m in matches]

    return standardized

# Test your function
test_text = """
Call us at 123-456-7890 or (555) 123-4567.
You can also reach us at 888.555.1234 or 999 888 7777.
Invalid: 12-34-5678, 1234567890
"""

q6_result = question_six(test_text)
print(f"Found phones: {q6_result}")

import re
import pandas as pd
from datetime import datetime

# Example: Simulated medical notes (replace this with your actual 500 notes)
# df = pd.Series([...])  # Length 500

def question_seven():
    """
    Extract dates from all medical notes and return indices sorted chronologically.

    Returns:
        pd.Series: Series of length 500 with original indices sorted by date
    """
    # Patterns for different date formats:
    patterns = [
        r'\b(0[1-9]|1[0-2])/([0-2][0-9]|3[01])/(\d{2}|\d{4})\b',         # MM/DD/YY or MM/DD/YYYY
        r'\b(0?[1-9]|[12][0-9]|3[01]) (January|February|March|April|May|June|July|August|September|October|November|December) (\d{4})\b',  # DD Month YYYY
        r'\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December) (0?[1-9]|[12][0-9]|3[01]), (\d{4})\b'  # Month DD, YYYY
    ]

    note_dates = []

    for i, note in enumerate(df):
        found = None
        for pattern in patterns:
            match = re.search(pattern, note)
            if match:
                date_str = match.group(0)
                try:
                    # Try parsing common date formats
                    for fmt in ["%m/%d/%Y", "%m/%d/%y", "%d %B %Y", "%b %d, %Y", "%B %d, %Y"]:
                        try:
                            dt = datetime.strptime(date_str, fmt)
                            found = dt
                            break
                        except ValueError:
                            continue
                    if found:
                        break
                except:
                    continue
        note_dates.append(found if found else pd.NaT)

    # Create DataFrame with original indices and dates
    temp_df = pd.DataFrame({'index': df.index, 'date': note_dates})

    # Sort by date
    sorted_indices = temp_df.sort_values(by='date', na_position='last')['index']

    return sorted_indices.reset_index(drop=True)

# Test the function
q7_result = question_seven()
print(f"Result length: {len(q7_result)}")
print(f"First 10 indices: {list(q7_result.head(10))}")
print(f"Last 10 indices: {list(q7_result.tail(10))}")

# Run this cell to verify all functions exist and return correct types
print("Checking functions...")

try:
    r1 = question_one()
    assert isinstance(r1, list), "question_one should return a list"
    print("✓ question_one: OK")
except Exception as e:
    print(f"✗ question_one: {e}")

try:
    r2 = question_two()
    assert isinstance(r2, list), "question_two should return a list"
    print("✓ question_two: OK")
except Exception as e:
    print(f"✗ question_two: {e}")

try:
    r3 = question_three()
    assert isinstance(r3, list), "question_three should return a list"
    print("✓ question_three: OK")
except Exception as e:
    print(f"✗ question_three: {e}")

try:
    r4 = question_four("test@email.com")
    assert isinstance(r4, list), "question_four should return a list"
    print("✓ question_four: OK")
except Exception as e:
    print(f"✗ question_four: {e}")

try:
    r5 = question_five("Hello World 123")
    assert isinstance(r5, str), "question_five should return a string"
    print("✓ question_five: OK")
except Exception as e:
    print(f"✗ question_five: {e}")

try:
    r6 = question_six("123-456-7890")
    assert isinstance(r6, list), "question_six should return a list"
    print("✓ question_six: OK")
except Exception as e:
    print(f"✗ question_six: {e}")

try:
    r7 = question_seven()
    assert isinstance(r7, pd.Series), "question_seven should return a pandas Series"
    print("✓ question_seven: OK")
except Exception as e:
    print(f"✗ question_seven: {e}")

print("\nDone! Export this notebook as .py file when all functions pass.")